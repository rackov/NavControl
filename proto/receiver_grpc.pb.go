// Синтаксис Protocol Buffers v3

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: receiver.proto

// Пакет для Go

package proto

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ReceiverControl_GetActiveConnectionsCount_FullMethodName = "/proto.ReceiverControl/GetActiveConnectionsCount"
	ReceiverControl_ListPorts_FullMethodName                 = "/proto.ReceiverControl/ListPorts"
	ReceiverControl_GetPortStatus_FullMethodName             = "/proto.ReceiverControl/GetPortStatus"
	ReceiverControl_GetConnectedClients_FullMethodName       = "/proto.ReceiverControl/GetConnectedClients"
	ReceiverControl_DisconnectClient_FullMethodName          = "/proto.ReceiverControl/DisconnectClient"
	ReceiverControl_OpenPort_FullMethodName                  = "/proto.ReceiverControl/OpenPort"
	ReceiverControl_ClosePort_FullMethodName                 = "/proto.ReceiverControl/ClosePort"
	ReceiverControl_AddPort_FullMethodName                   = "/proto.ReceiverControl/AddPort"
	ReceiverControl_ChangePortDescription_FullMethodName     = "/proto.ReceiverControl/ChangePortDescription"
	ReceiverControl_DeletePort_FullMethodName                = "/proto.ReceiverControl/DeletePort"
	ReceiverControl_GetProtocols_FullMethodName              = "/proto.ReceiverControl/GetProtocols"
)

// ReceiverControlClient is the client API for ReceiverControl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Сервис управления RECEIVER'ом
type ReceiverControlClient interface {
	// Получить количество активных подключений
	GetActiveConnectionsCount(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*GetActiveCount, error)
	// Получить список портов
	ListPorts(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ListPortsResponse, error)
	// Получить статус порта
	GetPortStatus(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*PortDefinition, error)
	// Получить список подключенных клиентов
	GetConnectedClients(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*GetClientsResponse, error)
	// Отключить клиента
	DisconnectClient(ctx context.Context, in *DisconnectClientRequest, opts ...grpc.CallOption) (*DisconnectClientResponse, error)
	// Открыть порт (сделать active=true)
	OpenPort(ctx context.Context, in *PortDefinition, opts ...grpc.CallOption) (*PortOperationResponse, error)
	// Закрыть порт (сделать active=false)
	ClosePort(ctx context.Context, in *PortDefinition, opts ...grpc.CallOption) (*PortOperationResponse, error)
	// Добавить новый порт в конфигурацию
	AddPort(ctx context.Context, in *PortDefinition, opts ...grpc.CallOption) (*PortOperationResponse, error)
	// Изменить описание порта
	ChangePortDescription(ctx context.Context, in *PortDefinition, opts ...grpc.CallOption) (*PortOperationResponse, error)
	// Удалить порт из конфигурации
	DeletePort(ctx context.Context, in *PortDefinition, opts ...grpc.CallOption) (*PortOperationResponse, error)
	// список протоколов
	GetProtocols(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Protocols, error)
}

type receiverControlClient struct {
	cc grpc.ClientConnInterface
}

func NewReceiverControlClient(cc grpc.ClientConnInterface) ReceiverControlClient {
	return &receiverControlClient{cc}
}

func (c *receiverControlClient) GetActiveConnectionsCount(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*GetActiveCount, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetActiveCount)
	err := c.cc.Invoke(ctx, ReceiverControl_GetActiveConnectionsCount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) ListPorts(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*ListPortsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPortsResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_ListPorts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) GetPortStatus(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*PortDefinition, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortDefinition)
	err := c.cc.Invoke(ctx, ReceiverControl_GetPortStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) GetConnectedClients(ctx context.Context, in *GetClientsRequest, opts ...grpc.CallOption) (*GetClientsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClientsResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_GetConnectedClients_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) DisconnectClient(ctx context.Context, in *DisconnectClientRequest, opts ...grpc.CallOption) (*DisconnectClientResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisconnectClientResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_DisconnectClient_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) OpenPort(ctx context.Context, in *PortDefinition, opts ...grpc.CallOption) (*PortOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortOperationResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_OpenPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) ClosePort(ctx context.Context, in *PortDefinition, opts ...grpc.CallOption) (*PortOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortOperationResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_ClosePort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) AddPort(ctx context.Context, in *PortDefinition, opts ...grpc.CallOption) (*PortOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortOperationResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_AddPort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) ChangePortDescription(ctx context.Context, in *PortDefinition, opts ...grpc.CallOption) (*PortOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortOperationResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_ChangePortDescription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) DeletePort(ctx context.Context, in *PortDefinition, opts ...grpc.CallOption) (*PortOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PortOperationResponse)
	err := c.cc.Invoke(ctx, ReceiverControl_DeletePort_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *receiverControlClient) GetProtocols(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Protocols, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Protocols)
	err := c.cc.Invoke(ctx, ReceiverControl_GetProtocols_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReceiverControlServer is the server API for ReceiverControl service.
// All implementations must embed UnimplementedReceiverControlServer
// for forward compatibility.
//
// Сервис управления RECEIVER'ом
type ReceiverControlServer interface {
	// Получить количество активных подключений
	GetActiveConnectionsCount(context.Context, *GetClientsRequest) (*GetActiveCount, error)
	// Получить список портов
	ListPorts(context.Context, *empty.Empty) (*ListPortsResponse, error)
	// Получить статус порта
	GetPortStatus(context.Context, *GetClientsRequest) (*PortDefinition, error)
	// Получить список подключенных клиентов
	GetConnectedClients(context.Context, *GetClientsRequest) (*GetClientsResponse, error)
	// Отключить клиента
	DisconnectClient(context.Context, *DisconnectClientRequest) (*DisconnectClientResponse, error)
	// Открыть порт (сделать active=true)
	OpenPort(context.Context, *PortDefinition) (*PortOperationResponse, error)
	// Закрыть порт (сделать active=false)
	ClosePort(context.Context, *PortDefinition) (*PortOperationResponse, error)
	// Добавить новый порт в конфигурацию
	AddPort(context.Context, *PortDefinition) (*PortOperationResponse, error)
	// Изменить описание порта
	ChangePortDescription(context.Context, *PortDefinition) (*PortOperationResponse, error)
	// Удалить порт из конфигурации
	DeletePort(context.Context, *PortDefinition) (*PortOperationResponse, error)
	// список протоколов
	GetProtocols(context.Context, *empty.Empty) (*Protocols, error)
	mustEmbedUnimplementedReceiverControlServer()
}

// UnimplementedReceiverControlServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReceiverControlServer struct{}

func (UnimplementedReceiverControlServer) GetActiveConnectionsCount(context.Context, *GetClientsRequest) (*GetActiveCount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveConnectionsCount not implemented")
}
func (UnimplementedReceiverControlServer) ListPorts(context.Context, *empty.Empty) (*ListPortsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPorts not implemented")
}
func (UnimplementedReceiverControlServer) GetPortStatus(context.Context, *GetClientsRequest) (*PortDefinition, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPortStatus not implemented")
}
func (UnimplementedReceiverControlServer) GetConnectedClients(context.Context, *GetClientsRequest) (*GetClientsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnectedClients not implemented")
}
func (UnimplementedReceiverControlServer) DisconnectClient(context.Context, *DisconnectClientRequest) (*DisconnectClientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectClient not implemented")
}
func (UnimplementedReceiverControlServer) OpenPort(context.Context, *PortDefinition) (*PortOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenPort not implemented")
}
func (UnimplementedReceiverControlServer) ClosePort(context.Context, *PortDefinition) (*PortOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClosePort not implemented")
}
func (UnimplementedReceiverControlServer) AddPort(context.Context, *PortDefinition) (*PortOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPort not implemented")
}
func (UnimplementedReceiverControlServer) ChangePortDescription(context.Context, *PortDefinition) (*PortOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePortDescription not implemented")
}
func (UnimplementedReceiverControlServer) DeletePort(context.Context, *PortDefinition) (*PortOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePort not implemented")
}
func (UnimplementedReceiverControlServer) GetProtocols(context.Context, *empty.Empty) (*Protocols, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProtocols not implemented")
}
func (UnimplementedReceiverControlServer) mustEmbedUnimplementedReceiverControlServer() {}
func (UnimplementedReceiverControlServer) testEmbeddedByValue()                         {}

// UnsafeReceiverControlServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReceiverControlServer will
// result in compilation errors.
type UnsafeReceiverControlServer interface {
	mustEmbedUnimplementedReceiverControlServer()
}

func RegisterReceiverControlServer(s grpc.ServiceRegistrar, srv ReceiverControlServer) {
	// If the following call pancis, it indicates UnimplementedReceiverControlServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReceiverControl_ServiceDesc, srv)
}

func _ReceiverControl_GetActiveConnectionsCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).GetActiveConnectionsCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_GetActiveConnectionsCount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).GetActiveConnectionsCount(ctx, req.(*GetClientsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_ListPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).ListPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_ListPorts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).ListPorts(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_GetPortStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).GetPortStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_GetPortStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).GetPortStatus(ctx, req.(*GetClientsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_GetConnectedClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).GetConnectedClients(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_GetConnectedClients_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).GetConnectedClients(ctx, req.(*GetClientsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_DisconnectClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisconnectClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).DisconnectClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_DisconnectClient_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).DisconnectClient(ctx, req.(*DisconnectClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_OpenPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).OpenPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_OpenPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).OpenPort(ctx, req.(*PortDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_ClosePort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).ClosePort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_ClosePort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).ClosePort(ctx, req.(*PortDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_AddPort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).AddPort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_AddPort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).AddPort(ctx, req.(*PortDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_ChangePortDescription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).ChangePortDescription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_ChangePortDescription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).ChangePortDescription(ctx, req.(*PortDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_DeletePort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PortDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).DeletePort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_DeletePort_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).DeletePort(ctx, req.(*PortDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReceiverControl_GetProtocols_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReceiverControlServer).GetProtocols(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReceiverControl_GetProtocols_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReceiverControlServer).GetProtocols(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ReceiverControl_ServiceDesc is the grpc.ServiceDesc for ReceiverControl service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReceiverControl_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ReceiverControl",
	HandlerType: (*ReceiverControlServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetActiveConnectionsCount",
			Handler:    _ReceiverControl_GetActiveConnectionsCount_Handler,
		},
		{
			MethodName: "ListPorts",
			Handler:    _ReceiverControl_ListPorts_Handler,
		},
		{
			MethodName: "GetPortStatus",
			Handler:    _ReceiverControl_GetPortStatus_Handler,
		},
		{
			MethodName: "GetConnectedClients",
			Handler:    _ReceiverControl_GetConnectedClients_Handler,
		},
		{
			MethodName: "DisconnectClient",
			Handler:    _ReceiverControl_DisconnectClient_Handler,
		},
		{
			MethodName: "OpenPort",
			Handler:    _ReceiverControl_OpenPort_Handler,
		},
		{
			MethodName: "ClosePort",
			Handler:    _ReceiverControl_ClosePort_Handler,
		},
		{
			MethodName: "AddPort",
			Handler:    _ReceiverControl_AddPort_Handler,
		},
		{
			MethodName: "ChangePortDescription",
			Handler:    _ReceiverControl_ChangePortDescription_Handler,
		},
		{
			MethodName: "DeletePort",
			Handler:    _ReceiverControl_DeletePort_Handler,
		},
		{
			MethodName: "GetProtocols",
			Handler:    _ReceiverControl_GetProtocols_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "receiver.proto",
}
